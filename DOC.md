# Gamified Question API

A gamified question API inspired by **Duolingo** and **Trivia Track**.  
The goal is to make learning more dynamic and fun.

---

## ðŸš€ Tech Stack

- **Language:** Kotlin with Coroutines
- **Framework:** Spring Boot
- **Database:** Supabase (PostgreSQL), Flyway (Migrations)
- **Auth:** JWT (via Supabase)

---

## ðŸ“š Features

### Questions

Each question includes:

- `id` (UUID)
- `statement` (String)
- `subject` (String)
- `topic` (String)
- `createdAt` (DateTime)
- `updatedAt` (DateTime)
- `alternatives` (auto-labeled A, B, C, â€¦)
- `questionType` (Enum: `multipleChoice` | `trueOrFalse`)

---

### Endpoints

- `POST /question` â†’ Create question (**ROLE_ADMIN**)
- `PUT /question/{id}` â†’ Update question (**ROLE_ADMIN**)
- `DELETE /question/{id}` â†’ Delete question (**ROLE_ADMIN**)
- `GET /question` â†’ List questions (paginated, public)
- `GET /question/{id}` â†’ Get question by ID

#### Filters:

- Year
- Subject
- Topic
- User status (answered, not answered, correct, wrong)

---

### Answering

- Auth required: **ROLE_USER** or **ROLE_ADMIN**
- Persisted fields:
  - `userId`
  - `questionId`
  - `chosenAlternative`
  - `correct` (Boolean)
  - `createdAt`

---

## ðŸ”‘ Authentication & Roles

- **ROLE_ADMIN** â†’ create/update/delete + answer
- **ROLE_USER** â†’ answer only
- **Anonymous** â†’ read only

Auth flow uses **JWT generated by Supabase**.

---

## ðŸ“„ API Response Examples

### Paginated response

````json
{
  "items": [...],
  "page": 1,
  "pageSize": 20,
  "totalPages": 10,
  "totalItems": 200
}

## ðŸ“Š Main Entities

- **profiles** â†’ mirrors `auth.users` (Supabase) and stores the role (`USER` / `ADMIN`).
- **subjects** â†’ taxonomy of subjects.
- **topics** â†’ taxonomy of topics.
- **questions** â†’ the question itself (type, year, subject).
- **question_topics** â†’ N:N relation between questions and topics (a question may cover multiple topics).
- **alternatives** â†’ answer choices (ordered and labeled as A, B, C, â€¦).
- **answers** â†’ actual user answers (1 row per attempt).
- **user_stats** *(optional)* â†’ aggregated data for gamification (XP, streak, etc.).
- **question_assets** *(optional)* â†’ media attachments (image/audio) stored in Supabase Storage.

---

## ðŸ—‚ï¸ Types & Enums

```sql
-- Question types
CREATE TYPE question_type AS ENUM ('MULTIPLE_CHOICE', 'TRUE_FALSE');

-- Access roles
CREATE TYPE app_role AS ENUM ('USER', 'ADMIN');

-- Aggregated status (for views/reports)
CREATE TYPE question_status AS ENUM ('UNANSWERED', 'CORRECT', 'INCORRECT');

## ðŸ—„ï¸ Database Schema (PostgreSQL / Supabase)

Below is the normalized schema for profiles, taxonomy (subjects/topics), questions, alternatives, answers, and helpful indexes/constraints for pagination and search.

> Notes
> - `profiles` mirrors `auth.users` and stores the application role.
> - `question_type`, `app_role`, and related enums should be created beforehand (see *Types & Enums* section).
> - Uses `pg_trgm` for fast text search on `statement`.

---

### SQL DDL

```sql
-- 1) Profiles (mirrors auth.users)
CREATE TABLE public.profiles (
  id UUID PRIMARY KEY REFERENCES auth.users(id) ON DELETE CASCADE,
  role app_role NOT NULL DEFAULT 'USER',
  display_name TEXT,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 2) Subjects
CREATE TABLE public.subjects (
  id BIGSERIAL PRIMARY KEY,
  name TEXT NOT NULL UNIQUE,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 3) Topics (child of subject)
CREATE TABLE public.topics (
  id BIGSERIAL PRIMARY KEY,
  subject_id BIGINT NOT NULL REFERENCES public.subjects(id) ON DELETE CASCADE,
  name TEXT NOT NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (subject_id, name)
);

-- 4) Questions
CREATE TABLE public.questions (
  id UUID PRIMARY KEY,
  statement TEXT NOT NULL,                -- question prompt
  subject_id BIGINT NOT NULL REFERENCES public.subjects(id) ON DELETE RESTRICT,
  year SMALLINT,                          -- year filter
  qtype question_type NOT NULL,
  is_active BOOLEAN NOT NULL DEFAULT TRUE,
  created_by UUID REFERENCES public.profiles(id) ON DELETE SET NULL,
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  updated_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- 4.1) M:N question â†” topic
CREATE TABLE public.question_topics (
  question_id UUID NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
  topic_id BIGINT NOT NULL REFERENCES public.topics(id) ON DELETE CASCADE,
  PRIMARY KEY (question_id, topic_id)
);

-- 5) Alternatives
CREATE TABLE public.alternatives (
  id UUID PRIMARY KEY,
  question_id UUID NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
  body TEXT NOT NULL,                      -- alternative text
  is_correct BOOLEAN NOT NULL DEFAULT FALSE,
  ord SMALLINT NOT NULL,                   -- position 1..N (A=1, B=2, ...)
  created_at TIMESTAMPTZ NOT NULL DEFAULT NOW(),
  UNIQUE (question_id, ord)
);

-- (Auto-generated label A/B/C/...)
ALTER TABLE public.alternatives
ADD COLUMN label TEXT GENERATED ALWAYS AS (
  chr(64 + ord) -- 65 = 'A'
) STORED;

-- Guarantee: exactly 1 correct alternative per question (MC and TRUE_FALSE)
CREATE UNIQUE INDEX ux_alternatives_one_correct_per_question
  ON public.alternatives (question_id)
  WHERE is_correct;

-- 6) Answers (user attempts history)
CREATE TABLE public.answers (
  id UUID PRIMARY KEY,
  user_id UUID NOT NULL REFERENCES public.profiles(id) ON DELETE CASCADE,
  question_id UUID NOT NULL REFERENCES public.questions(id) ON DELETE CASCADE,
  alternative_id UUID NOT NULL REFERENCES public.alternatives(id) ON DELETE RESTRICT,
  is_correct BOOLEAN NOT NULL,             -- decided at insert time
  answered_at TIMESTAMPTZ NOT NULL DEFAULT NOW()
);

-- Query helpers for user/question status filters
CREATE INDEX ix_answers_user_question ON public.answers (user_id, question_id);
CREATE INDEX ix_answers_user_correct ON public.answers (user_id, is_correct);
CREATE INDEX ix_answers_question ON public.answers (question_id, answered_at DESC);

-- Question listing filters
CREATE INDEX ix_questions_subject_year ON public.questions (subject_id, year);
CREATE INDEX ix_questions_qtype ON public.questions (qtype);
CREATE INDEX ix_questions_active ON public.questions (is_active);

-- Text search on statement (requires pg_trgm)
CREATE EXTENSION IF NOT EXISTS pg_trgm;
CREATE INDEX ix_questions_statement_trgm ON public.questions USING gin (statement gin_trgm_ops);

-- Stable ordering for pagination
CREATE INDEX ix_questions_created_at_id ON public.questions (created_at DESC, id);
````
